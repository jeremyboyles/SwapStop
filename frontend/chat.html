<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Chat</title>
  <style>
    body{font-family:Arial;margin:16px;background:#222}
    /* chat message area */
    #log{
      height:300px;
      overflow:auto;
      border:1px solid #ccc;
      padding:12px;
      background:#ffffff;
      color:#111;
      border-radius:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    /* message row */
    .msg-row{display:flex;flex-direction:column;max-width:100%}
    .msg-row.other{align-items:flex-start}
    .msg-row.me{align-items:flex-end}
    /* bubble */
    .bubble{
      display:inline-block;
      padding:8px 12px;
      border-radius:12px;
      background:#f1f1f1;
      color:#111;
      word-break:break-word;
      box-shadow:0 1px 0 rgba(0,0,0,0.03);
      max-width:70%;
    }
    .bubble.me{
      background:#22c55e; /* green */
      color:#fff; /* white text */
      border-bottom-right-radius:4px;
    }
    .meta{font-size:0.8em;color:#666;margin-bottom:4px}
    /* image in bubble */
    .bubble img{max-width:240px;border-radius:8px;display:block}
    .bubble.me img{max-width:240px}
    /* make form labels white */
    label{ color: #ffffff; margin-right:8px; }
    /* controls */
    #controls{margin:8px 0 12px 0;display:flex;gap:8px;align-items:center}
    #msg{flex:1;padding:8px;border-radius:6px;border:1px solid #ccc}
    #send, #connect, #imgBtn{padding:8px 10px;border-radius:6px;background:#22c55e;border:0;color:#021014;cursor:pointer}
    #imgFile{display:none}

    /* preview area */
    #preview{display:none;align-items:center;gap:8px;margin-bottom:8px}
    #preview img{max-width:160px;max-height:120px;border-radius:8px;border:1px solid #ccc}
    #preview .preview-info{color:#fff;font-size:0.9em}
    #preview .remove-preview{background:transparent;border:0;color:#fff;font-size:18px;cursor:pointer;padding:4px 8px}
  </style>
</head>
<body>
  <label>Room: <input id="room" value="lobby"></label>
  <label>User: <input id="user" value="user1"></label>
  <button id="connect">Connect</button>

  <div id="log" aria-live="polite"></div>

  <!-- image preview (shown when user selects an image) -->
  <div id="preview" role="region" aria-label="Image preview">
    <img id="previewImg" alt="preview">
    <div class="preview-info" id="previewInfo"></div>
    <button class="remove-preview" id="removePreview" title="Remove image">âœ•</button>
  </div>

  <div id="controls">
    <input id="msg" placeholder="message">
    <button id="imgBtn" title="Upload image">ðŸ“·</button>
    <input id="imgFile" type="file" accept="image/*">
    <button id="send">Send</button>
  </div>

  <script>
    let ws;
    let currentUser = null;
    let pendingImage = null; // dataURL of chosen image waiting to be sent
    let pendingImageName = '';

    function buildWsUrl(room, user) {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const host = location.host || '127.0.0.1:8000';
      return `${proto}://${host}/ws/${encodeURIComponent(room)}/${encodeURIComponent(user)}`;
    }

    function appendRow(sender, text, isNotice=false, isMe=false, imgSrc=null){
      const d = document.getElementById('log');
      const row = document.createElement('div');
      row.className = 'msg-row ' + (isMe ? 'me' : 'other');

      if(isNotice){
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = text;
        row.appendChild(meta);
      } else {
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = isMe ? `You â€¢ ${new Date().toLocaleTimeString()}` : `${sender} â€¢ ${new Date().toLocaleTimeString()}`;
        row.appendChild(meta);

        const bubble = document.createElement('div');
        bubble.className = 'bubble' + (isMe ? ' me' : '');
        if(imgSrc){
          const img = document.createElement('img');
          img.src = imgSrc;
          img.alt = text || 'image';
          bubble.appendChild(img);
          if(text){
            const caption = document.createElement('div');
            caption.textContent = text;
            caption.style.marginTop = '6px';
            caption.style.color = isMe ? '#e8fff0' : '#111';
            bubble.appendChild(caption);
          }
        } else {
          bubble.textContent = text;
        }
        row.appendChild(bubble);
      }

      d.appendChild(row);
      d.scrollTop = d.scrollHeight;
    }

    function sendImageDataUrl(dataUrl, caption=''){
      if(ws && ws.readyState === WebSocket.OPEN){
        // send special token; server will broadcast "username: __img__:<dataurl>::<caption>"
        // caption is optional and escaped by replacing '::' if present (simple delimiter)
        const safeCaption = caption.replace(/::/g, ':: ');
        ws.send(`__img__:${dataUrl}::${safeCaption}`);
      } else {
        appendRow('', 'WebSocket not connected', true, false);
      }
    }

    function clearPreview(){
      pendingImage = null;
      pendingImageName = '';
      document.getElementById('preview').style.display = 'none';
      document.getElementById('previewImg').src = '';
      document.getElementById('previewInfo').textContent = '';
      document.getElementById('imgBtn').textContent = 'ðŸ“·';
      const f = document.getElementById('imgFile');
      if(f) f.value = '';
    }

    function doSend(){
      const t = document.getElementById('msg').value.trim();
      // if an image is pending, send it with the message text as the caption
      if(pendingImage){
        if(ws && ws.readyState === WebSocket.OPEN){
          const safeCaption = (t || '').replace(/::/g, ':: ');
          ws.send(`__img__:${pendingImage}::${safeCaption}`);
          // clear pending image and UI hint
          clearPreview();
          document.getElementById('msg').value = '';
          return;
        } else {
          appendRow('', 'WebSocket not connected', true, false);
          return;
        }
      }
      if(!t) return;
      if(ws && ws.readyState === WebSocket.OPEN){
        ws.send(t);
        document.getElementById('msg').value = '';
      } else {
        appendRow('', 'WebSocket not connected', true, false);
      }
    }

    document.getElementById('connect').onclick = () => {
      const room = document.getElementById('room').value || 'lobby';
      const user = document.getElementById('user').value || 'anon';
      currentUser = user;
      const url = buildWsUrl(room, user);
      try {
        ws = new WebSocket(url);
      } catch (err) {
        appendRow('', 'WebSocket constructor error: ' + err.message, true, false);
        return;
      }

      ws.onopen = () => appendRow('', 'Connected to ' + url, true, false);

      ws.onmessage = (e) => {
        const m = e.data;
        if (m.startsWith('__join__:')) {
          const who = m.split(':')[1] || '';
          appendRow('', `${who} joined`, true, false);
        } else if (m.startsWith('__leave__:')) {
          const who = m.split(':')[1] || '';
          appendRow('', `${who} left`, true, false);
        } else {
          // normal message: expected "sender: message"
          const idx = m.indexOf(':');
          if(idx > -1){
            const sender = m.slice(0, idx).trim();
            const body = m.slice(idx + 1).trim();
            const isMe = (currentUser && sender === currentUser);

            // image protocol: body starts with "__img__:<dataurl>::<caption>"
            if(body.startsWith('__img__:')){
              const payload = body.slice('__img__:'.length);
              const sep = '::';
              const pIdx = payload.indexOf(sep);
              let dataUrl, caption;
              if(pIdx > -1){
                dataUrl = payload.slice(0, pIdx);
                caption = payload.slice(pIdx + sep.length);
              } else {
                dataUrl = payload;
                caption = '';
              }
              appendRow(sender, caption || '', false, isMe, dataUrl);
            } else {
              appendRow(sender, body, false, isMe);
            }
          } else {
            // fallback: raw text
            appendRow('', m, false, false);
          }
        }
      };

      ws.onclose = (ev) => appendRow('', 'Disconnected (code ' + ev.code + ')', true, false);
      ws.onerror = () => appendRow('', 'WebSocket error', true, false);
    };

    document.getElementById('send').onclick = doSend;

    document.getElementById('msg').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        doSend();
      }
    });

    // image upload flow
    const imgBtn = document.getElementById('imgBtn');
    const imgFile = document.getElementById('imgFile');
    const previewEl = document.getElementById('preview');
    const previewImg = document.getElementById('previewImg');
    const previewInfo = document.getElementById('previewInfo');
    const removePreviewBtn = document.getElementById('removePreview');

    imgBtn.addEventListener('click', () => imgFile.click());

    imgFile.addEventListener('change', () => {
      const f = imgFile.files && imgFile.files[0];
      if(!f) return;
      if(!f.type.startsWith('image/')) { appendRow('', 'Selected file is not an image', true, false); imgFile.value = ''; return; }
      const reader = new FileReader();
      reader.onload = () => {
        // store the dataURL and show indicator; actual send happens when user presses Send
        pendingImage = reader.result;
        pendingImageName = f.name;
        // visual hint on the button that an image is queued
        imgBtn.textContent = 'ðŸ“· âœ“';
        // show preview
        previewImg.src = pendingImage;
        previewInfo.textContent = pendingImageName;
        previewEl.style.display = 'flex';
      };
      reader.readAsDataURL(f);
      // keep file input reset handled in clearPreview or after send
    });

    removePreviewBtn.addEventListener('click', () => {
      clearPreview();
    });
  </script>
</body>
</html>